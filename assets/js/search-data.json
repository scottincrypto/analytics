{
  
    
        "post0": {
            "title": "Stableswap Shoot-out",
            "content": "Stablecoin Swaps . Stablecoins arguably form the basis for decentralised finance on Ethereum. Whether it&#39;s borrowing, lending, liquidity provision or yield farming, there are almost always stablecoins in the middle of it. The stablecoins we are referring to here are the 3 big USD pegged stablecoins - USDC, USDT and DAI. Defi is full of decentralised token exchanges - dex - which exchange one token for another. A specialised use case of the dex is stablecoin swaps - exchanging between USDC, USDT and DAI either to get the right token for the job users need to do, or to arbitrage between 3 assets that should be worth USD 1 each but often are not exactly. As the value of each of these coins is close to equal, a number of optimisations to the traditional AMM dex model have evolved for stablecoin swaps. The intent of this post is to look at the efficiency of these alternatives &amp; see which one gives the best results for users. . Stableswap Efficiency . Firstly we should define what we mean by efficiency of a stablecoin swap. Let&#39;s imagine a magical world where USDC, USDC and DAI are worth exacly 1 USD each. Right now, it&#39;s really close to that, but certain parties assign different risk discounts to each coin and it is not always the case. We will make the assumption that these coins are equivalent in underlying value as the arbitrage trade is enormous and relatively efficient. A perfect stablecoins swap should therefore be receiving tokens at a 1:1 ratio. It is almost always less than this, due to four areas of loss for the user: . Swap fees - a dex will generate revenue by taking a percentage of each swap. It is a competitive market for stableswaps, and these fees are often very low - 0.05% for Uniswap v3 and 0.03% for Curve on stablecoin swaps. | Price Impact - The quoted price on a dex is the price for the next token swapped, regardless of the size of the trade. Dex type exchanges rely on a pool of liquidity for each token in the swap, with the actual swap price being a function of the ratio of the tokens in the pool after the swap occurs. If the swap is a significant portion of the pool liquidity it can move the realised price that the user receives. This can be mitigated by the design of the AMM, particularly with stablecoin swaps where the swap range between tokens is very narrow. This is a key component of our analysis here - dex protocols don&#39;t just compete on fees, they also compete on the swap curve design. A number of our target protocols have optimised the swap curve to minimise price impact on swaps. | Slippage - a blockchain is a dynamic environment, being used by potentially millions of users at any one time. Slippage occurs when the quoted price of a swap changes due to the action of other simultaneous market participants. A user can submit a swap at a given price, but if a large transaction occurs at around the same time, the user may receive more or less than expected because of this transaction. This is known as slippage, and most dex UIs include a limit on slippage tolerance for the user. If the slippage is more than the tolerance, the transaction will fail. | Blockchain Transaction Fees - the Ethereum network uses the ETH token to pay for blockspace in the blockchain, and this payment is called gas. Blockspace is a limited resource and there is a free market for inclusion. Prices are high during times of congestion and lower at other times. Gas prices form a significant portion of dex impact for users, particularly with lower value swaps. | . The focus of this post is the user - what does the user get in a stablecoins swap, compared with the 1:1 ideal situation? . Dex Models . Before we begin, an outline of each dex model is in order: . Uniswap V2 - Constant Product AMM . Uniswap launched as the OG Automated Market Maker dex, based on a Reddit post by Vitalik in 2016. It uses the constant product model - x * y = k, where the price of a token in a dex pool is equal to the ratio of that token to the other token in the pool. Uniswap was hugely successful with this model, spawning many imitators. . Curve - Optimised Swap Curves for Stableswaps . Constant product dex markets are subject to price impact and slippage. They are optimised for swapping between a large number of tokens, rather than efficient swaps between a small number. Michael Egorov, the founder of Curve, recognised this and founded Curve, with a swap curve more efficient than the constant product model for swaps of tokens of a similar value. It was enormously successful and has attracted over USD 12b of liquidity. Curve has the Tripool - an AMM pool for USDC, USDT and DAI with over USD 2b of liquidity alone. . Uniswap V3 - Targeted Liquidity . In the constant product AMM model, the liquidity is spread over all prices for both tokens. For pegged stablecoins, where the price of each coin is well within 1% of the price of the other coins, this means that much of the liquidity is never utilised. Uniswap launched V3 of their protocol, allowing users to target their liquidity around specified price points. This had a major impact on the capital efficiency of stablecoin swap pools and helped to close the market gap to Curve. . Balancer . Balancer uses a single vault model, where users interact with a single contract for all swaps. The swap logic is abstracted away to underlying pools so that the user only pays gas fees on the vault transactions. The underlying pools implement optimised swap curves for the target tokens, giving users advantages in swap efficiency and gas usage. . Saddle . Imitation is the sincerest form of flattery. Saddle launched to outcries of copyright infringement with their Curve inspired stableswap AMM. Let&#39;s see how it stacks up. . Judging the Stableswap Options . To analyse which is the best option for users when swapping stablecoins, we collected on-chain data from Flipside Crypto. This data looked at swaps between the three major pegged stablecoins (USDC, DAI, USDT) on the five platforms described above (Curve, Uniswap V2 &amp; V3, Balancer, Saddle). Sushi was excluded from the analysis as it carries very low liquidity in stable-stable pair pools - it appears most stableswaps are done via intermediate tokens like ETH. Data was sourced which met the following criteria: . Swaps occured during the last 2 months (to 2021-09-17) | Swaps weren&#39;t done via aggregators like 1inch or Paraswap - direct with the protocol only | Swaps weren&#39;t routed between intermediate pairs - they were direct in &amp; out of the stablecoin pools | Transactions with zero gas fees were excluded - services like Flashbots allow advanced users to substitute gas costs with direct payments to block miners. | . The analysis centered on the return to the users - for every token swapped in a stablecoin swap, how much was lost in the transaction. Assuming that each of our stablecoins is equivalent in value (1 USD), this was calculated by dividing the received token amount by the submitted token amount. This was done in two ways: . Excluding gas costs - looking at swap fees, price impact &amp; slippage only. This give insight into the underlying design &amp; liquidity of the swap protocol. | Including gas costs - the net outcome for the user. The only thing that really matters. | . Note on Balancer - Balancer swaps can include a rebate in BAL tokens for user gas costs. These have not been considered in this analysis, because they have been interpreted as a usage incentive which may not persist, rather than as an underlying part of the protocol. . Overall Performance Across all Stableswap Pairs . The first analysis makes the assumption that USDC, DAI and USDC are equivalent in value, so we don&#39;t differentiate between swap pairs (yet). For all the transactions which meet the criteria in the paragraph above, we look at the transaction cost to the user. This transaction cost, expressed as a percentage, is the amount lost compared to the ideal 1:1 swap from a perfect exchange. More formally, it is: . . For example, if the user puts in 100 USDC and receives 99 DAI, then the transaction cost % would be 1%. Lower is better. . Excluding Gas . The chart below shows the transaction cost % across all pairs over the last 2 months, excluding the impacts of gas. As we can see, Curve is the most cost efficient dex, with an average transaction cost impact of under .04%. Curve charges 0.03% as a protocol fee on the Tripool, so there is around 0.01% of slippage &amp; price impact on stablecoin trades on Curve. Compare this to Uniswap v3, which has 0.05% fees. The Uniswap v3 overall cost impact is less than the fees, indicating that there may be some positive slippage &amp; price impact for users on the platform. Here we also see the benefits of optimising for stablecoin swaps over a generall AMM model. The Uniswap V2 platform - built for swapping many different tokens over all price ranges - is an order of magnitude more costly than the optimised stableswap dex environments. . . . Including Gas . It&#39;s no secret that gas costs have been prohibitive on Ethereum over the past 2 months. The NFT boom has driven up competition for blockspace and gas levels have been consistently high, as well as suffering from extraordinary short term spikes. When we factor this into the analysis the results are as below. Curve is still the most efficient dex overall, with an average impact of 0.045%. Uniswap v3 is next, then there is daylight to the others. As gas costs in a transaction are a fixed amount the impact of gas will depend on the swap size. There is probably a swap size influence on these numbers below - this will be investigated further. . . . Performance by Swap Size . The charts below show how much volume is swapped on the exchanges in different swap size classes. We can see that for swap sizes below USD 100k, Uniswap has the most volume across both v2 and v3. For swap sizes between 100k and 1m, Curve and Uniswap v3 dominate. Above 1m, Curve is the clear choice for stablecoin swaps. We can conclude that for small swaps, users favour the popularity &amp; ease of use of the Uniswap platform, but for serious sized swaps there is a greater sophistication and a desire to get the best deal possible. We also see that Balancer &amp; Saddle have insignificant swap amounts compared with the others. It&#39;s worth reinforcing that the swaps investigated here are only those done directly via the protocols - much of the volume routed through Balancer &amp; Saddle are likely coming from aggregators and other protocols. . . . Excluding Gas Costs . The graph below shows the transaction costs, excluding gas, segmented by swap size. The charts are relatively consistent, with Curve being the best performer across all classes. An interesting trend is the increase in costs in Uniswap v2 as the swap size increases. This is due to price impacts in the pool - the larger swaps are a big enough proportion of the total pool liquidity to impact the price. . . . Including Gas Costs . Now we see the real outcome for the user, with gas costs included. The charts below show the total transaction cost, including gas, across the different swap size cohorts. Please note the scales are now different on each chart to allow better comparison. We see that for smaller swap sizes (&lt; 10k), the gas efficiency of Uniswap v3 makes this the cheapest option for users. There is a significant margin in this advantage for very small swaps (&lt; 1k). As swap sizes increase, however, the underlying protocol and liquidity advantage of Curve washes away the gas costs and we see Curve as the best performing dex for swap sizes larger than USD 10k . . . Return by Swap Pair . To confirm the conclusions above, we will look to see if there is any influence on transaction costs based on the swap pair. The chart below shows the volume of swaps by swap pair. There is a difference in volume between the most popular and least popular swap directions of around 3x - we will see if this influences the transaction cost outcomes. . . . Transaction Cost by Swap Pair . The charts below shows the transaction costs, including gas, split by the swap pairs. The trend is relatively consistent across all pairs, and conistent with the overall conclusions we have made. Curve is the best performing dex across the board, followed by Uniswap v3. An interesting feature of these charts are the DAI-USDT and DAI-USDC performance of Curve - the transaction costs are much lower than the average, probably due to favourable price impact in the swaps. For the DAI-USDC swap direction there is a negative cost for the user - the user receives more USDC than the DAI swapped in. . . . Conclusions . In attempting to do a fair comparison between stablecoin swap platforms, we examined nearly $3b of transactions over a 2 month period, looking at swaps done directly with these swap platforms. We found the following: . Curve is, on aggregate, the cheapest place to swap the big 3 stablecoins. | For smaller transactions (&lt; 10k USD), Uniswap v3 appears to be cheaper due to gas cost efficiency | For larger transactions than 10k, Curve is the clear winner | There is a big advantage in transaction costs using a specialised stablecoin swap platform, as opposed a general purpose dex like Uniswap v2 | Simply copying an existing concept is not a recipe for instant success for Saddle - the weight of liquidity in Curve translates to better outcomes for users, which begets even more liquidity and cheaper costs | . If you are a user looking to swap stablecoins (USDC, USDT, DAI), then Curve should be the first choice. It&#39;s worth a comparison with Uniswap v3, however, as it may be slightly more gas efficient on smaller trades. Happy swapping. . References: . All data was sourced from the curated on-chain data tables at Flipside Crypto | Insights on dex pricing impacts were from this article by Hasu at https://research.paradigm.xyz/amm-price-impact | The idea for this post was inspired by this article at the fantastic Curve Market Cap https://curve.substack.com/p/august-18-2021-curve-vs-balancer | .",
            "url": "https://scottincrypto.github.io/analytics/curve/2021/09/19/Curve_Stableswaps.html",
            "relUrl": "/curve/2021/09/19/Curve_Stableswaps.html",
            "date": " • Sep 19, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Polygon Bridging Behaviour",
            "content": "Introduction . This post seeks to answer the following questions: . Where do people go when they bridge to Polygon from Ethereum? What are the 10 most popular first destinations for Polygon addresses that have just bridged from Ethereum? What has this been for each day in the past month? . Polygon operates as a sidechain to Ethereum, with funds moved to &amp; from Polygon via a series of bridges. These bridges accept tokens on the Ethereum side, then create wrapped versions of the same tokens on the Polygon side. Users are attracted to Polygon by the low fees &amp; fast transactions speeds relative to Ethereum. In the absence of fiat onramps, bridges are the only way into the ecosystem. There are a number of bridges in operation by different operators, but this analysis will focus on the official Polygon bridge provided by the protocol. . About the Data . This dataset looks at all of the transactions coming into Polygon via the Polygon Bridge over the last month. It then looks at the next transaction each wallet undertook in the currency that was bridged in, and classifies the destination of that transaction. In examining the data, a couple of observations were noted: . Often the first transaction was a very small swap for MATIC - the token used for gas on Polygon | Most of the coins bridged were either USDC, USDT, WBTC or WETH. Only 3% were other coins, and there was a very long list of these other coins. | . To simplify the analysis, we excluded any next transaction with a value of less than USD 10, and looked at the transaction after this instead. This lets us see the intent of the user more than looking at their initial MATIC swap transaction instead. We also limited our analysis to the 4 major coins above - this accounts for 97% of the funds bridged (as per the table below) and allowed us to simplify the charts for better insights. . All data was sourced from Flipside Crypto . Bridged Token USD Amount Percentage . 1 USDC | 4.457159e+08 | 45.0 | . 2 USDT | 2.783901e+08 | 28.0 | . 3 WBTC | 1.622389e+08 | 16.0 | . 4 WETH | 8.141258e+07 | 8.0 | . 5 other | 2.897250e+07 | 3.0 | . Top Destinations . The destination addresses &amp; contracts were classified by project or protocol to understand where users were going after bridging to Polygon. We managed to classify over 70 of these destination contracts to account for over 75% of the value moved. There was a very long tail (over 23k addresses) accounting for the remaining 25% of the value - these are labelled as &quot;Unknown&quot; in the data going forward. . The graph below shows the next destination of the bridged funds. Aave is the top destination, with a lot of value coming into Polygon to take part in borrowing &amp; lending activities. A number of familiar names from the Ethereum ecosystem are in the list - Curve, 1inch, Balance, Sushi - but there are a few non-Ethereum specific names in the list - Quickswap, Iron Finance, Polynetwork. An interesting find in this list are the bridges - a signficant portion of funds were immediately bridged out of Polygon after being bridged in. This was done via the Polygon Bridge (&quot;Bridge Out&quot;) or via the Allbridge facility. It&#39;s possible users are using Allbridge to get to chains such as Solana or Binance using Polygon as an intermediate step. . . . Flow of Funds . By Destination . The graph below shows the flow of funds from bridge, by token bridged, into the destination protocols shown above. We can see the large flows into Aave - interestingly most of the Aave flow is USDC, USDT or WBTC. WETH makes up only a small portion of the flow. WETH yields are usually low on Aave, but WBTC yields are too. Low yields do not show the full picture of user behaviour here. . . . By Use Case . To simplify the above graph, each destination was classified into a broad use case grouping. This is shown in the graph below. Users coming to Polygon for Defi activities (Aave, Iron Finance etc) account for the largest grouping. Here we see the amount of funds bridge immediately back out of Polygon - 11% of funds bridge in are immediately bridged out. Another observation from this graph is that there is a small amount of hodling occuring - this is seen where the inflows to each token are less than the outflows. . . . Most Popular Destinations by Day . The chart below shows, by day, the ranking of each of the destinations by the USD amount sent to them. This chart is very busy and a littled difficult to intepret. To target a particular protocol, double-click on the protocol in the legend and the graph will isolate just that protocol. Clicking on another protocol after this will add it to the graph. Double-click again to return to all values. . Aave is consistently the top performer, being always ranked at number 4 or higher. The unknown category also features highly - indicating that there are a wide variety of destinations on Polygon and it&#39;s not just a small handful capturing all the action. The behaviour with bridges continues to yield interesting insight - Allbridge has risen to be a consistent top 5 destination in the last 2 weeks - perhaps this is coincident with the rise in interest in Solana, as Allbridge can be used to bridge to this chain. . . . Most Popular Use Cases by Day . To simplify the above graph, we used the broader classes of use cases rather than the destination protcols. Here we see that Defi usage is on average the highest - this contains Aave. Users are obviously keen to generate yield from their funds in Polygon, taking advantage of the low fees relative to Ethereum to deposit their funds. We also see that funds jumping straight to dex swaps has dropped off - 3-4 weeks ago this was the highest use case, now it is amongst the lowest. . . . Conclusions . The Polygon Bridge allows users to bring funds from Ethereum into the Polygon ecosystem. We have looked at what users do once they bridge funds in. We have discovered the following insights: . 97% of value bridged in is 4 tokens - USDT, USDC, WBTC, WETH - with a long tail of other tokens. | The top single destination for bridged funds is depositing on Aave. | There is a mix of Ethereum-based protocols used (Aave, Curve, Balancer, Sushi) and protocols that are based in other chains like Polygon &amp; BSC (Quickswap, Iron Finance). The former indicates users bridging to Polygon for the lower fee environment, but the latter indicates there may be pull due to some unique opportunities on the ecosystem. | We saw 11% of funds bridged in immediately bridged out in the next transaction. It&#39;s possible that Polygon is being used as an intermediate step to bridge to other ecosystems. | We looked at the most popular destinations and use cases by day - Defi usage (depositing, yield seeking) is consistently the most common use case, driven by Aave. | .",
            "url": "https://scottincrypto.github.io/analytics/polygon/2021/09/18/_09_15_Polygon_Bridge.html",
            "relUrl": "/polygon/2021/09/18/_09_15_Polygon_Bridge.html",
            "date": " • Sep 18, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Terra Validator Churn",
            "content": "Introduction . The Terra network operates a set of proof of stake validator nodes to provide security for the network. Validators are judged on their uptime and on the quality of their validation - any deviations from expectations can result in slashing and loss of funds for the validator operator. This post explores some uptime &amp; downtime insights of the Terra validator nodes. . How often do Validators go down? . How often do validators that have been online at least once in the past 6 months turn off? It turns out, that on average, it happens pretty often - once every 1.6 hours for each validator (see table below). This simple statistic doesn&#39;t really tell the story though - there are some very reliable validators and some rather unreliable ones making up this average. . We took a dataset of all validators who collected rewards over the last 6 months, and looked for the liveness events recorded on chain. These events are collected by the protocol and used in slashing calculations for nodes that haven&#39;t met their validation requirements. These events keep a record of how many blocks a validator missed validating. . Taking these liveness events and looking at how many, on average, each validator has had over this time (adjusting for how long the validator has been running), we can calculate an average time between downtime events for each validator. Another name for this metric is Mean Time Between Failure (MTBF) - a common metric in Asset Management. We can plot the MTBF for each validator and see what the distribution looks like below. . MTBF . 1 1.6 | . . . We see there is a large variation between validators, pointing towards the conclusion that there are a number of very professional outfits, and potentially some less skilled or resourced node operators on the network. There are 4 validators who operate with an MTBF of greater than 60 hours (one downtime event every 2-3 days) and there are nearly 50 who operate at less than 2 hours between each downtime event. . Change in MTBF Over Time . To see how the MTBF metric has changed over the last 6 months, we plot the MTBF (per validator) over time below. We can see there has been a marked decrease in MTBF over the 6 months, with early weeks as high as 6 hours between downtime events, trending down to less than 1 hour per event per validator. This indicates a decrease in the overall reliability of the validator nodes over this time period. . . . High Performing Validators . We saw earlier that there was a distinct difference between the best and worst performing validators. The graph below segments the data to just look at the top 10 best performing validators (by number of downtime events relative to their operating time) over the last 6 months. Here we also see a downward trend. Earlier, MTBF ranged in the hundreds of hours between failures. This has trended down to around 30 hours between dowtime events. Notice that this is more than an order of magnitude better than the current average of around 1 hour. . . . Low Performing Validators . Performing the same analysis on the worst 10 validators (by downtime events) we can see why the average is so low. The most recent week average MTBF for this group is around 8 minutes, and there is a distinct downtrend from 6 months ago when this number was as high as 1 hour. This mirrors what we have seen in the rest of the dataset - reliability is trending downwards. . . . Conclusions . The data above has explored the downtime events among Terra validators. We have seen that, on average over the entire validator set, validators miss blocks around once every 1.6 hours. There is a vast difference between validators however - the best 10 validators currently miss blocks every 30 hours and the worst 10 miss one every 8 minutes. Across all datasets there has been a trend of decreasing reliability compared with 6 months ago. . References . All data sourced from Flipside Crypto. Data sources: . https://api.flipsidecrypto.com/api/v2/queries/5eebcedf-5edd-4afd-931a-5932d5fbf964/data/latest https://api.flipsidecrypto.com/api/v2/queries/9c6e455a-66eb-45f9-b87a-c76d716e0040/data/latest https://api.flipsidecrypto.com/api/v2/queries/7013252f-a0fe-43b2-abea-b4f42e319210/data/latest https://api.flipsidecrypto.com/api/v2/queries/5ac709ee-887c-4522-9bc8-15cec97720e0/data/latest .",
            "url": "https://scottincrypto.github.io/analytics/terra/validators/2021/09/18/_09_12_Terra_Validator_Churn.html",
            "relUrl": "/terra/validators/2021/09/18/_09_12_Terra_Validator_Churn.html",
            "date": " • Sep 18, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Anchor bAsset Usage",
            "content": "Here we attempt to answer the questions: . What is the number of users who are using Anchor to both borrow against their bAssets and place those borrows directly in Earn? What is the average leverage LTV risk they are taking in doing this? . Anchor is a borrow/lend protocol on the Terra Blockchain. It accepts assets for collateral (Luna and Eth), however these assets must be bonded first - a locked form of staking. Hence the collateral tokens accepted are bLuna and bEth. Once these bTokens are deposited in Anchor, users are able to borrow UST against, up to a maximum Loan-to-Value ratio of 60%. The LTV is simply the borrowed amount in UST divided by the current USD value of the collateral. If the LTV goes above 60% due to the collateral value falling, the loan can be liquidated and the borrower will lose a portion of the capital to repay the loan. . Anchor also has a deposit facility, where users can deposit UST and earn an interest rate from it. At the time of writing this article, the yields are very health. Anchor deposits earn 19.44% APR. This yield is slightly lower than the borrow interest rate - 21.1%, however there are ANC incentive rewards on the borrow side. This gives a net borrow interest rate of 18.8% in favour of the borrower. Yes, you read that correctly - you are paid to borrow money and paid again to deposit back into the protocol. . Number of Users Borrowing &amp; Depositing . With this deal on offer (possibly the best stablecoin yield in DeFi) it is no surprise that lots of users are taking up the offer. In pulling these data together, there were well over 0.5m transactions on the protocol. It was clear that users do multiple transactions - the table below shows 15,523 unique wallets who had both borrowed money from Anchor and deposited a sum back into the Earn portion. . A quick note on the data aggregation method - because of the large numbers of transactions, the data was simplified according the following rules: . Data was aggregated by day | A users collateral deposit &amp; withdrawal events were summed over the day, with the resulting collateral amount being the running total of all their collateral transactions to the end of that day | A users borrow &amp; repayment events were also summed over the day, with the resulting net borrowing position amount being the running total of all their borrow/repay transactions to the end of that day | Users deposit events were summed over the day | . This approach simplified the data considerably (0.5m events down to 65k events) but generated a small number of edge cases which didn&#39;t make sense after aggregation. These were driven by intra-day events - if a user deposited collateral, borrowed against it, deposited, withdrew the deposit, repaid the loan then withdrew the collateral, this would show up as a borrow event with no loan and no collateral. These small number of edge events (1000 or so) were filtered from the dataset. The remaining data will still be representative of user behaviour. There is also the underlying assumption that if a user deposited on the same day they borrowed, then they were depositing the borrowed money. . Unique Wallets . 1 15523 | . How much do People Borrow? . It&#39;s worth a look at what the typical loan sizes are for the people who are borrowing and depositing back into Anchor. The graph below shows, for each unique wallet, what was the peak borrow position for that wallet. In other words, of all the days that the user deposited back into Anchor Earn, what was the largest loan total they over those days. This gives us a feel for how deep each user was prepared to borrow from Anchor. . The graph below shows this distribution, with the maximum loan position along the bottom of the graph. It shows that most wallets borrow between 100 UST and 10,000 UST. Given the excellent returns, it&#39;s no surprise to see some big accounts. There are over 100 wallets who had over 1m UST outstanding, and 15 who had more than 15m UST outstanding. . . . What Collateral Assets are Used? . When Anchor launched the only available collateral asset was bonded Luna (bLuna), available from bonding Luna tokens to a validator via the Anchor protocol. In August 2021, Ether became an Anchor asset. This was done via the Lido protocol on Ethereum. Users are able to wrap ETH or stETH (ETH already staked on Lido) into a bEth token which represents their staked ETH on the Terra blockchain. This allows users to retain long term exposure to ETH, whilst taking advantage of the yields on offer in Anchor. Unsurprisingly, users have taken advantage of this. The graph below shows the % of collateral assets deposited in Anchor by our users (those who are both borrowing &amp; depositing on Anchor). After launch, the % of bEth as collateral quickly jumped to around 5% of the total. Expect to see this rise as more users find out about this yield opportunity. Anchor plans to add more assets to the potential collateral pool in the future. . . . Loan to Valuation Ratio . Average LTV . To calculate the Loan to Valuation Ratios, on each day that a user made a deposit, we took the outstanding loan position and divided it by the collateral position on that day - using that days underlying asset prices. The table below shows the average LTV ratio for all users - around 32%. This is around half of the liquidation cuttof of 60%, and is lower than the Anchor recommended LTV of 45%. It appears users are relatively conservative with their loans - no surprises given how volatile the underlying assets can be. . Average LTV % Weighted Average LTV % . 1 31.6 | 32.7 | . Distribution of LTVs . The graph below shows a histogram of the LTVs for all days where a wallet deposited borrowed funds in Anchor. Standout features include a big spike around 35% - this seems to be the most popular range. There are also spikes in 5% increments from 20% through to 45% - it seems that people gravitate towards multiples of 5. An evolutionary impact of having 5 fingers perhaps? It is also clear that most users borrow at less than the Anchor recommended LTV of 45%. There are a small numbers of thrillseekers however who deposit right up to the 60% limit. Liquidation stats for these users would be interesting. . . . LTV by Borrow Position Size . Next we will see if there is any correlation between the size of a users outstanding borrow position and the LTV they choose when borrowing. The graph below shows a clear trend - lower value borrowers have a lower LTV and higher borrowers take on more liquidation risk. In particular, the accounts with &gt;1m UST outstanding have the highest LTVs - around 38% on average. It&#39;s possible that these users spend more time watching the markets, perhaps understand them better and are confident to take on a higher amount of risk. . The graph below this one is the same data, but shown with a boxplot. The same trend is evident, and we see that the &gt;1m UST borrowers have a narrower range of LTV. . . . . . LTV Over Time . Looking at LTV over time, we see some variation - LTV ranges between around 28% at the low point, and around 35% at a high. Interesting datapoints include the sharp drop in LTV in mid-May 2021. THis was the time when crypto asset prices suffered sharp and substantial drops. It&#39;s possible that higher leveraged positions were flushed out by liquidations during these rapid price falls. The sharp rise in LTV from June through to August coincided with Luna rising in price from USD 6 to USD 30 - this obviously gave users confidence to borrow against these rising positions &amp; take advantage of the juicy Anchor borrow &amp; deposit rates. . . . LTV by Borrow Position Size over Time . We will repeat the chart from above, but split by our borrow size cohorts from the previous sections. There are common trends evident in the data - the May 2021 price crash seemed to impact all users. An interesting group is the 1m-10m UST borrow group - they seem to push the LTV consistently up towards 40%, indicating a purposeful and managed approach to farming yield on Anchor. . . . Conclusions . The on-chain data has shown over 15,000 unique wallets which are both borrowing from Anchor and depositing in the Earn facility at the same time. These users, on average have an LTV of around 32%. This LTV differs depending on the size of the loan, with larger users prepared to take on more liquidation risk. The LTV has changed over time, seemingly in response to market pricing changes in underlying assets. In particular, there was suggestion that rapid price falls caused liquidations, leading to lower overall LTVs. . Data sourced from Flipside Crypto: https://api.flipsidecrypto.com/api/v2/queries/1d474896-d69b-41f3-9f6f-e9c1f5a70a5f/data/latest .",
            "url": "https://scottincrypto.github.io/analytics/terra/anchor/2021/09/18/_09_08_Anchor_bAssets_Usage.html",
            "relUrl": "/terra/anchor/2021/09/18/_09_08_Anchor_bAssets_Usage.html",
            "date": " • Sep 18, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Flipside Crypto Prize Winning Bounty Projects",
            "content": "Yearn Bounties . Yearn TVL and ROI Comparing Yearn Strategies as featured as Bounty of the Week and in this Flipside Crypto Blog . Terra Network Bounties . Exploring Mirror Airdrop featured in this Flipside Crypto blog post Terra New User Inflow featured as Bounty of the Week Terra Validator Rankings featured in this Flipside Crypto blog Terra Transaction Fees Terra Tax Rate Terra Validators Self Delegating Angel Protocol Delegations . Uniswap Bounties . Uniswap Fee Volatility featured in this Flipside Crypto Blog Uniswap Voting Power Distribution featured in this Flipside Crypto Blog Defi Users vs Newbies . Compound Protocol Bounties . Compound APY Volatility Compound Investment Strategy Impacts of Crypto Price Crash on Compound Users Compound Collateralization Ratio Typical Compound Users Compound Flash Loans Compound - Miners &amp; Liquidations Flipside Crypto blog featuring some of these Compound Bounties .",
            "url": "https://scottincrypto.github.io/analytics/flipside/2021/09/01/Flipside-Crypto-Grand-Prize-Winning-Bounties.html",
            "relUrl": "/flipside/2021/09/01/Flipside-Crypto-Grand-Prize-Winning-Bounties.html",
            "date": " • Sep 1, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Exploring Yearn TVL & ROI",
            "content": "#Imports &amp; settings import pandas as pd import seaborn as sns import matplotlib.pyplot as plt import plotly.express as px import plotly.graph_objects as go from plotly.subplots import make_subplots sns.set_theme(style=&quot;ticks&quot;, color_codes=True) %matplotlib inline %load_ext rpy2.ipython %R options(tidyverse.quiet = TRUE) %R options(lubridate.quiet = TRUE) %R options(jsonlite.quiet = TRUE) %R suppressMessages(library(tidyverse)) %R suppressMessages(library(lubridate)) %R suppressMessages(library(jsonlite)) %R suppressMessages(options(dplyr.summarise.inform = FALSE)) . ListVector with 1 elements. dplyr.summarise.inform &lt;rpy2.rinterface_lib.sexp.NULLType object at 0x7f4f9ad69e10&gt; [RTYPES.NILSXP] | . %%R #Grab base query from Flipside df = fromJSON(&#39;https://api.flipsidecrypto.com/api/v2/queries/79667064-b29f-4297-9a9e-c8e162beb2fa/data/latest&#39;, simplifyDataFrame = TRUE) #Change the date to date format df$DATE &lt;- parse_datetime(df$DATE) #Rename &amp; reorder columns df = df %&gt;% rename(asset_symbol = ASSET_SYMBOL, burn_amount = BURN_AMOUNT, date = DATE, mint_amount = MINT_AMOUNT, net_ytoken_increase = NET_YTOKEN_INCREASE, ytoken_price = YTOKEN_PRICE, pricing_symbol = PRICING_SYMBOL, token_price = TOKEN_PRICE, vault_name = VAULT_NAME, vault_symbol = VAULT_SYMBOL, ytoken_price = YTOKEN_PRICE, exposure = EXPOSURE) %&gt;% select(date, vault_name, vault_symbol, asset_symbol, exposure, mint_amount, burn_amount, net_ytoken_increase, ytoken_price, pricing_symbol, token_price) ###Fill in the missing data #create a date sequence from min date to max date full_date_range &lt;- tibble(date = seq(min(df$date), max(df$date), by = &quot;days&quot;)) #create a new empty df df_full_dates &lt;- df %&gt;% filter(vault_symbol == &quot;yeehaa&quot;) #create the list of vaults to iterate over vault_list &lt;- df %&gt;% distinct(vault_symbol) #iterate over the vaults and fill the missing bits - I know I should vectorise this, please don&#39;t be disappointed in me for(vault in vault_list$vault_symbol) { #filter to a single vault single_vault &lt;- df %&gt;% filter(vault_symbol == vault) #store the min_date min_date &lt;- min(single_vault$date) #join on the full date range single_vault &lt;- full_date_range %&gt;% left_join(single_vault, by = &quot;date&quot;) #chop off data prior to min_date single_vault &lt;- single_vault %&gt;% filter(date &gt;= min_date) #fill chars with above, prices with above, mint/burns with zero single_vault &lt;- single_vault %&gt;% fill(vault_name) %&gt;% fill(vault_symbol) %&gt;% fill(asset_symbol) %&gt;% fill(exposure) %&gt;% fill(pricing_symbol, .direction = &quot;downup&quot;) %&gt;% fill(ytoken_price, .direction = &quot;downup&quot;) %&gt;% fill(token_price, .direction = &quot;downup&quot;) %&gt;% replace_na(list(mint_amount = 0, burn_amount = 0, net_ytoken_increase = 0)) #append the newly fixed data to the df_full_dates &lt;- df_full_dates %&gt;% bind_rows(single_vault) } #update the master df df &lt;- df_full_dates ### Calculate ROIs #7 Day ROI - define ROI as the annualised 7 day vault return - assume 52 weeks/year #calculate the 7 day lagged value of ytoken_price tmp &lt;- df %&gt;% select(vault_name, date, ytoken_price) %&gt;% group_by(vault_name) %&gt;% mutate(ytoken_lag7 = lag(ytoken_price, n=7, order_by = date)) %&gt;% ungroup() df &lt;- df %&gt;% bind_cols(tmp %&gt;% select(ytoken_lag7)) #Calculate 7 day ROI df &lt;- df %&gt;% mutate(vault_7day_ROI = (ytoken_price - ytoken_lag7) * 52 * 100) # ROI from inception #Generate min ytoken price &amp; inception date by vault tmp &lt;- df %&gt;% select(vault_name, date, ytoken_price) %&gt;% group_by(vault_name) %&gt;% mutate(ytoken_inception_price = min(ytoken_price), #price is always increasing according to docs inception_date = min(date), days_since_inception = as.numeric(as.duration(inception_date %--% date), &quot;days&quot;) ) %&gt;% ungroup() df &lt;- df %&gt;% bind_cols(tmp %&gt;% select(ytoken_inception_price, inception_date)) #Calculate ROI since inception df &lt;- df %&gt;% mutate(days_since_inception = as.numeric(as.duration(inception_date %--% date), &quot;days&quot;), vault_inception_ROI = (ytoken_price - ytoken_inception_price) / days_since_inception * 365 * 100 ) ### Calculate deposited tokens and TVL #Generate a running total (cumsum) of mints &amp; burns to get tokens issued df &lt;- df %&gt;% group_by(vault_name) %&gt;% mutate(ytokens_on_issue = cumsum(net_ytoken_increase)) %&gt;% ungroup() #Calculate ytokens on issue and TVL df &lt;- df %&gt;% mutate(asset_tokens_deposited = ytokens_on_issue * ytoken_price, total_assets_usd = asset_tokens_deposited * token_price) #filter vaults with data errors (waiting fix from Flipside) #df &lt;- df %&gt;% filter(!(vault_symbol %in% c(&quot;yvUSDT&quot;, &quot;yvWBTC&quot;))) #Tag top10 by TVL top10_by_tvl &lt;- df %&gt;% filter(date == max(date)) %&gt;% arrange(desc(total_assets_usd)) %&gt;% head(10) %&gt;% select(vault_name) %&gt;% mutate(top10_tvl = 1) df &lt;- df %&gt;% left_join(top10_by_tvl, by = &quot;vault_name&quot;) df$top10_tvl &lt;- replace_na(df$top10_tvl, 0) #Tag the top10 by 7 day ROI top10_by_7roi &lt;- df %&gt;% filter(date == max(date)) %&gt;% arrange(desc(vault_7day_ROI)) %&gt;% head(10) %&gt;% select(vault_name) %&gt;% mutate(top10_7day_roi = 1) df &lt;- df %&gt;% left_join(top10_by_7roi, by = &quot;vault_name&quot;) df$top10_7day_roi &lt;- replace_na(df$top10_7day_roi, 0) #Tag the top10 by inception ROI top10_by_inceproi &lt;- df %&gt;% filter(date == max(date)) %&gt;% arrange(desc(vault_inception_ROI)) %&gt;% head(10) %&gt;% select(vault_name) %&gt;% mutate(top10_inception_roi = 1) df &lt;- df %&gt;% left_join(top10_by_inceproi, by = &quot;vault_name&quot;) df$top10_inception_roi &lt;- replace_na(df$top10_inception_roi, 0) . Exploring Yearn - TVL and ROI . Introduction to Yearn . Yearn is a DeFi yield aggregator protocol. There are a million different ways to earn yield on your tokens in DeFi. Some are risky, some are safe, and some are really complex. Yearn aims to simplify this for users by providing a simple interface to deposit tokens and earn yield. Yearn provides a series of vaults, based around a deposit asset type, in which users can deposit an asset to earn yield. Behind the scenes, Yearn automates the allocation of funds from vaults into strategies, which use cutting edge yield-farming techniques to bring gains back to the vault. Users can withdraw a larger number of tokens at a later date, with the gains representing the yield earned by the vault strategists. There are a couple of key things to know about Yearn: . Yields are earned in the denomination of the vault | Users retain exposure to the deposited asset whilst it is in the vault | . For example, you deposit ETH into a vault &amp; withdraw a week later. ETH price has dropped. You will have more ETH than when you deposited, but the USD value of that ETH may be less than you had at the beginning. This is actually an advantage for some users - if a user wants to maintain exposure to an asset (say ETH, or BTC, because they think it will go up in the longer term), they can deposit in a corresponding vault to earn yield whilst they are hodling. Yearn also has a handy feature to further support this - you can deposit into any vault using ETH, WBTC, DAI, USDC, or USDT, and Yearn will automatically swap into the vault deposit asset. . . Yearn Vaults v2 . Yearn launched version 2 of its Vaults in July 2020. These were a major upgrade on the original vaults, allowing up to 20 strategies to service a single vault. Prior to v2, Yearn Vaults only had one strategy. Most of the v2 Vaults have 2 or more strategies, with automatic logic working to allocate user funds to these strategies to get the best return fo the Vault. This dashboard will focus on the top 20 Yearn v2 Vaults by TVL. These vaults account for around US $2.6b of value out of the US $3.5b listed on Defi Pulse. There are over 100 different Yearn vaults &amp; other products (iearn, v1 vaults), but these top v2 vaults represent most of the value locked in Yearn at the moment. We will use the abbreviation TVL (Total Value Locked) to refer to the USD value deposited in Vaults. . Growth in Value of V2 Vaults . The graph below shows the growth of the top 20 V2 vaults over 2021. This growth has been a mix of organic protocol growth, and the migration of funds from obsolete vaults (v1 or older v2 vaults). Note the falls in value which occurred in May &amp; June 2021, when there were rapid drops in the value of most crypto assets agains the USD. . #Plot TVLs df_p = %R df %&gt;% filter(vault_symbol != &quot;yvCurve-triCrypto&quot;) %&gt;% group_by(date) %&gt;% summarise(top10_tvl_by_date = sum(total_assets_usd)) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;top10_tvl_by_date&quot;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults - Total Value of Top 20 Vaults in USD&#39;) fig.update_yaxes(title_text=&#39;USD Value&#39;) fig.show() . . . . Which Vaults Hold the Value? . The chart below shows the value by Vault for the top 10 vaults by value. Before we take a good look, it is a good time to talk about vault names &amp; what they mean. You&#39;ll notice the vault names below all start with yv - it doesn&#39;t take a genius to figure that means Yearn Vault. You&#39;ll then notice there are two types of names: . yv &lt;Token Name&gt; - these are vaults where the deposited token (example - WETH for the yvWETH vault) are used for yield farming by the vault strategies | yvCurve- &lt;Curve Pool Name&gt; - these vaults start by depositing the tokens into the corresponding Curve Pool, then yield farming with the resulting deposit token. Curve is a dex, specialising in stablecoin swaps and big brained mathemetics. Yearn uses Curve pools as the basis for many of their Vaults. | . In the graph below, you&#39;ll see that the biggest pool by value is the USDC pool, followed closely by the DAI pool. These are both USD pegged stablecoins. In fact, so is IronBank, LUSD, USDT and USDN - 6 out of the top 10 vault assets. There are three ETH based vaults, and the Yearn governance token, YFI, is also in the list. . An interesting feature of this chart is the large increases of the yvUSDC vault on the 7th of June, and the yvDAI vault on 29th of June. The USDC transaction was a US $180m deposit from what looks like a whale account, and the DAI transaction was a series Yearn protocol operations - possibly a migration of funds from an older version of the yvDAI vault to this one. . Usage tip - The graphs in this dashboard are interactive. Click on a plot trace in the legend once to turn it on &amp; off. Double-click on a plot trace in the legend to turn off everything but the selected plot. Click &amp; drag in the plot area to zoom. Double-click the chart area to unzoom. . #Plot ROI since inception df_p = %R df %&gt;% filter(top10_tvl == 1) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;total_assets_usd&quot;, color=&#39;vault_symbol&#39;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults TVL (Top 10 Vaults Only)&#39; ) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=0.99, xanchor=&quot;left&quot;, x=0.01 )) fig.update_yaxes(title_text=&#39;USD Value&#39;) fig.show() . . . . Vault Return on Investment . Defining ROI . Vault returns are defined as a Return on Investment - ROI. This is usually an annualised number, which represents the returns you might get if you deposited in a vault for a year. There are a number of caveats around this however - the returns often change over time, and the returns are denominated in the vault deposit asset. This is a bit different to a traditional APR or APY definition, although yearn.finance does use the APY label on it&#39;s ROI calculation on the main Vault deposit page. It describes this as &quot;annualised weekly yield&quot; which is more or less the definition we will use. . Each Vault has an exchange rate built into it - deposit 1 token, get a bit less than one yvtoken in return. Over time, 1 deposit token will buy less and less yvtokens - the price is always rising. For a given investment, the ROI is determined by the following formula, where the Buy &amp; Sell prices are the number of native tokens required to buy the yvtokens: . $ROI_{annualised} = frac{(SellPrice) - (BuyPrice)}{TimeInYears}$ . For comparison of Vault returns we will use a rolling 7 day period to determine the ROI. This matches the yearn.finance approach and, let&#39;s face it, we are in DeFi and we have very short investment horizons. More info on calculating ROI can be found at Yearn Docs and this helpful notebook on Github. The graphs below are an example of the ROI calculations for the yvUSDC v2 Vault. The top chart shows the price of a yvUSDC token in USDC, and the chart below it is the annualised 7 day ROI. You will notice that the Vault yield travelled happily along between 15-25% until the May 2021 Crypto Crash, after which yields fell to around 5%. This will be a recurring theme when we look at other Vault returns. . #Plot subplots of ytoken price &amp; ROI df_p = %R df %&gt;% filter(vault_symbol == &quot;yvUSDC&quot;) fig = make_subplots(rows=2, cols=1, subplot_titles=(&quot;yvUSDC Price (in USDC)&quot;, &quot;yvUSDC 7 Day Annualised ROI&quot;)) fig.append_trace(go.Scatter(x=df_p[&quot;date&quot;], y=df_p[&quot;ytoken_price&quot;], name=&quot;Price&quot;), row=1, col=1) fig.append_trace(go.Scatter(x=df_p[&quot;date&quot;], y=df_p[&quot;vault_7day_ROI&quot;], name=&quot;ROI&quot;), row=2, col=1) fig.update_layout(width=800, height=800/1.618, title_text=&quot;yvUSDC Price &amp; Returns&quot;) fig.update_layout(template=&quot;simple_white&quot;, showlegend=False) fig.update_yaxes(title_text=&#39;yvUSDC Price in USDC&#39;, row=1, col=1) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;, row=2, col=1) fig.show() . . . ROI of the Largest Vaults . We have seen from above that a huge chunk of capital is tied up in the top 10 Yearn v2 Vaults. Do these large vaults generate large returns for the depositors? It turns out that it depends on the vault, and on the timing. . The two charts below show the ROI of the top 10 Yearn v2 Vaults by value. The first chart shows the individual Vaults, and the 2nd is an average ROI of these vaults weighted by the vault value. . We see that most of these vaults have seen a steady reduction in ROI from earlier in the year through to the present. Returns north of 20% were typical, but they have steadily declined to hover in the 0-10% band. The average chart shows a slight recovery in yields over the last month, giving some hope for better returns in the future. Of the individual Vaults, the yvCurve-stETH vault, the yvCurve-USDN vault and the yvCurve-IronBank vault appear to have been slightly higher returns than others over time. . Tip - Use the zoom feature to better explore the difference between the vaults, particularly in later months. . #Plot ROIs df_p = %R df %&gt;% filter(top10_tvl == 1) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;vault_7day_ROI&quot;, color=&#39;vault_symbol&#39;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI - Top 10 Vaults by TVL&#39;) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig.update_yaxes(range=[0, 70]) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=0.99, xanchor=&quot;right&quot;, x=1.1 )) fig.show() df_p = %R df %&gt;% filter(top10_tvl == 1) %&gt;% group_by(date) %&gt;% summarise(weighted_av = weighted.mean(vault_7day_ROI, total_assets_usd, na.rm = TRUE)) fig2 = px.line(df_p, x=&quot;date&quot;, y=&quot;weighted_av&quot;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI - Average of Top 10 Vaults by TVL&#39;) fig2.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig2.show() . . . . . Which Vaults Have the Largest ROI? . Enough about the biggest vaults. Let&#39;s see who&#39;s got the biggest returns. . We have the same set of charts below as the section above, but this time we are looking at the top 10 Vaults by ROI, instead of value. We can see that, on average, the returns from these vaults are higher than the previous chart - currently 7.5% compared with 5.7%. In earlier times, returns were much higher in the best performing vaults. . One vault stands out as being consistently higher than the the others, even when returns have dropped off. The yvBOOST Vault, also known as the Yearn Compounding veCRV yVault, is a single strategy vault which accepts yveCRV-DAO tokens. These tokens entitle the owner to a share of Curve&#39;s trading fees, which are harvested, swapped for more yveCRV-DAO and deposited back into the vault. Thus the returns are auto compounding. The results are impressive, with the ROI staying over 16% right through the current bearish market. . Tip - Use the zoom feature to better explore the difference between the vaults, particularly in later months. . #Plot ROIs df_p = %R df %&gt;% filter(top10_7day_roi == 1) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;vault_7day_ROI&quot;, color=&#39;vault_symbol&#39;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI - Top 10 Vaults by ROI&#39;) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig.update_yaxes(range=[0, 70]) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=1.1, xanchor=&quot;left&quot;, x=0.01, font=dict( size=11, ) )) fig.show() df_p = %R df %&gt;% filter(top10_7day_roi == 1) %&gt;% group_by(date) %&gt;% summarise(weighted_av = weighted.mean(vault_7day_ROI, total_assets_usd, na.rm = TRUE)) fig2 = px.line(df_p, x=&quot;date&quot;, y=&quot;weighted_av&quot;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI - Average of Top 10 Vaults by ROI&#39;) fig2.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig2.show() . . . . . Returns since Inception . Just say you&#39;re a bored ape and you jump on every new Yearn vault on the day it launches. What do the returns on the Yearn v2 Vaults look like since inception? The graph below tells the story, showing the top 10 vaults by ROI since inception. The clear winner is yvCurve-sETH, at 27% ROI since inception. This vault relies on Curve &amp; Convex protocols to earn staking rewards, which are swapped &amp; reinvested back into the vault. Another interesting datapoint is yvBOOST - it&#39;s the only vault which has seen the returns since inception steadily rising. . #Plot ROIs df_p = %R df %&gt;% filter(top10_inception_roi == 1) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;vault_inception_ROI&quot;, color=&#39;vault_symbol&#39;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI Since Inception&#39;) fig.update_yaxes(range=[0, 100]) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=0.99, xanchor=&quot;right&quot;, x=0.99 )) fig.show() . . . . Returns Based on Asset Exposure . As mentioned in the introduction, users maintain exposure to the deposited asset when they ape into a Yearn vault. Yearn gives the users plenty of choice from this perspective. There are vaults which take deposits of: . ETH in the form of WETH, sETH, stETH and others | BTC in the form of WBTC, sBTC, oBTC, pBTC and others | Stablecoins - DAI, USDC, USDT, FRAX, EURS, alUSD and others | DeFi tokens - YFI, eCRV-DAO, LINK and others | . Is there a difference in the returns from Yearn Vaults between these asset classes? The graphs below attempts to answer this question. The first chart below shows the volume weighted average ROI of the vaults in each of the asset exposure groups. . Stablecoin yields have consistently been stronger over the period of this chart. Whilst they have decreased substantially from the 15-25% in the midst of the crypto price boom, they have settled at a respectable 7% in recent weeks. ETH denominated vaults have followed the same trend, albeit at lowe roverall levels. ETH returns have settled down at around 2% - better than you get from a savings account, but low in the realms of DeFi. Our DeFi tokens have performed somewhere in between. With only three tokens in the pool, this is more to do with these vaults than generally about DeFi. BTC based vaults are low, but have been steadily increasing from 1.5% through to the current range of 4-5%. Interestingly, BTC returns have outpaced ETH returns from the end of June through to the present. This is a rare case of BTC flippening ETH - don&#39;t tell the BTC Maxies! . The 2nd chart below shows all of the individual vaults in the dataset, split by underlying asset exposure. Here are some observations: . The ETH value has been driven by the yvCurve-SETH pool - it has returned significantly more than the other ETH denominated pools, even in recent weeks when crypto pricing has been depressed. The underlying Curve pool earns boosted CRV rewards which probably accounts for much of this good performance. | yvBOOST accounts for most of the ROI in the DeFi tokens, being the best performing vault in the dataset. The yYFI vault in particular has a very low return. Users probably aren&#39;t buying YFI for the yield in Yearn, and are happy to get some return whilst they hodl for capital appreciation. | The stablecoins aren&#39;t easy to differentiate - current yields range from 5-12% and the best yielding vault changes often. | BTC returns are mainly driven by two pools - pBTC and oBTC. The native BTC pool - yvWBTC - provides very modest returns, ranging between 0.5% and 2%. | . #Plot TVLs df_p = %R df %&gt;% filter (date &gt;= ymd(&#39;2021-05-01&#39;)) %&gt;% filter(vault_symbol != &quot;yvCurve-triCrypto&quot;) %&gt;% group_by(date,exposure) %&gt;% summarise(weighted_av = weighted.mean(vault_7day_ROI, total_assets_usd, na.rm = TRUE)) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;weighted_av&quot;, color=&#39;exposure&#39;, template=&quot;simple_white&quot;, width=800, height=800/1.618, title= &#39;Yearn v2 Vaults ROI by Underlying Asset Exposure&#39;) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;) #fig.update_yaxes(range=[0, 70]) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=0.99, xanchor=&quot;right&quot;, x=0.99 )) fig.show() . . . df_p = %R df %&gt;% filter(vault_symbol != &quot;yvCurve-triCrypto&quot;) %&gt;% filter (date &gt;= ymd(&#39;2021-05-01&#39;)) fig = px.line(df_p, x=&quot;date&quot;, y=&quot;vault_7day_ROI&quot;, color=&#39;vault_symbol&#39;, facet_row=&#39;exposure&#39;, template=&quot;simple_white&quot;, width=1000, height=1200/1.618, title= &#39;Yearn v2 Vaults ROI by Underlying Asset Exposure - Individual Vaults&#39;) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;) fig.show() . . . . Conclusions . Our exploration of Yearn has uncovered a number facts. Most of the Yearn TVL is accounted for by v2 Vaults, and the biggest v2 Vaults contain the popular stablecoins DAI and USDC. Yearn has a close relationship with Curve, and uses Curve pools in many of the Vaults &amp; Strategies to earn yield for users. Yearn ROI is calculated from the price of the yvToken at different points in time. We have seen that this ROI is volatile - past peformance is not a prediction of future returns! We have seen that the largest vaults by value are not always the vaults with the best ROI. We also saw that the yvBOOST vault is a standout in terms of its investment returns, consistently outperforming other vaults and even improving returns over time. Finally, we took a look at which asset class has the best returns over time - stablecoins consistently provide better returns than most other asset classes. . Data in this notebook was sourced from Flipside Crypto. . Interactive Feature - TVL and ROI for Any Vault . #@markdown Select a Vault to see the TVL &amp; ROI chart for that Vault: selected_vault = &quot;yvBOOST&quot; #@param [&quot;yvBOOST&quot;, &quot;yvCurve-alUSD&quot;, &quot;yvCurve-EURS&quot;, &quot;yvCurve-FRAX&quot;, &quot;yvCurve-IronBank&quot;, &quot;yvCurve-LINK&quot;, &quot;yvCurve-LUSD&quot;, &quot;yvCurve-oBTC&quot;, &quot;yvCurve-pBTC&quot;, &quot;yvCurve-sBTC&quot;, &quot;yvCurve-sETH&quot;, &quot;yvCurve-stETH&quot;, &quot;yvCurve-triCrypto&quot;, &quot;yvCurve-USDN&quot;, &quot;yvDAI&quot;, &quot;yvUSDC&quot;, &quot;yvUSDT&quot;, &quot;yvWBTC&quot;, &quot;yvWETH&quot;, &quot;yvYFI&quot;] #@markdown *If the charts don&#39;t automatically update, re-run the notebook from the Runtime-&gt;Run All option in the menu bar. You may also need to click the play button at the top left. You should only have to do this once per session.* #Plot subplots of ytoken price &amp; ROI df_p = %R df df_p = df_p[df_p.vault_symbol==selected_vault] fig = make_subplots(rows=2, cols=1, subplot_titles=(selected_vault + &quot; USD Value&quot;, selected_vault + &quot; 7 Day Annualised ROI&quot;)) fig.append_trace(go.Scatter(x=df_p[&quot;date&quot;], y=df_p[&quot;total_assets_usd&quot;], name=&quot;TVL in USD&quot;), row=1, col=1) fig.append_trace(go.Scatter(x=df_p[&quot;date&quot;], y=df_p[&quot;vault_7day_ROI&quot;], name=&quot;ROI&quot;), row=2, col=1) fig.update_layout(width=800, height=600, title_text=selected_vault + &quot; TVL &amp; ROI&quot;) fig.update_layout(template=&quot;simple_white&quot;, showlegend=False) fig.update_yaxes(title_text=&#39;Value in USD&#39;, row=1, col=1) fig.update_yaxes(title_text=&#39;ROI % Annualised&#39;, row=2, col=1) fig.show() . . .",
            "url": "https://scottincrypto.github.io/analytics/yearn/2021/09/01/Exploring_Yearn_TVL_and_ROI.html",
            "relUrl": "/yearn/2021/09/01/Exploring_Yearn_TVL_and_ROI.html",
            "date": " • Sep 1, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Scott Simpson @scottincrypto . Available for Crypto Analytics work, including: . Dune Analytics | Flipside Crypto | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://scottincrypto.github.io/analytics/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://scottincrypto.github.io/analytics/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}