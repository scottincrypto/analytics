{
  
    
        "post0": {
            "title": "Anchor bAsset Usage",
            "content": "#Imports &amp; settings import pandas as pd import seaborn as sns import matplotlib.pyplot as plt import plotly.express as px import plotly.graph_objects as go from plotly.subplots import make_subplots sns.set_theme(style=&quot;ticks&quot;, color_codes=True) %matplotlib inline #%load_ext google.colab.data_table %load_ext rpy2.ipython %R options(tidyverse.quiet = TRUE) %R options(lubridate.quiet = TRUE) %R options(jsonlite.quiet = TRUE) %R suppressMessages(library(tidyverse)) %R suppressMessages(library(lubridate)) %R suppressMessages(library(jsonlite)) %R suppressMessages(options(dplyr.summarise.inform = FALSE)) . ListVector with 1 elements. dplyr.summarise.inform &lt;rpy2.rinterface_lib.sexp.NULLType object at 0x7f0850390050&gt; [RTYPES.NILSXP] | . %%R #Grab base query from Flipside df = fromJSON(&#39;https://api.flipsidecrypto.com/api/v2/queries/1d474896-d69b-41f3-9f6f-e9c1f5a70a5f/data/latest&#39;, simplifyDataFrame = TRUE) #Change the date to date format df$DATE &lt;- parse_datetime(df$DATE) #Rename &amp; reorder columns df &lt;- df %&gt;% rename(beth_position = BETH_POSITION, bluna_position = BLUNA_POSITION, borrows = BORROWS, collateral_position = COLLATERAL_POSITION, date = DATE, deposit_amount = DEPOSIT_AMOUNT, eth_usd = ETH_USD, luna_usd = LUNA_USD, net_borrow_position = NET_BORROW_POSITION, sender = SENDER, ) %&gt;% select(date, sender, eth_usd, luna_usd, beth_position, bluna_position, collateral_position, borrows, net_borrow_position, deposit_amount) #remove the accounts with a negative loan balance - works around some errors in the source data df_filtered&lt;- df %&gt;% mutate(neg_borrow = if_else(net_borrow_position &lt; 1, 1, 0)) %&gt;% group_by(sender) %&gt;% filter(neg_borrow == 0) %&gt;% ungroup() #loan distro - maximum loan size by wallet histogram max_size_histo &lt;- df_filtered %&gt;% group_by(sender) %&gt;% summarise(max_loan = max(net_borrow_position)) %&gt;% arrange(desc(max_loan)) %&gt;% mutate(sort_bucket = case_when( max_loan &lt; 1 ~ &quot;0-1&quot;, max_loan &lt; 10 ~ &quot;1-10&quot;, max_loan &lt; 1e2 ~ &quot;10-100&quot;, max_loan &lt; 1e3 ~ &quot;100-1k&quot;, max_loan &lt; 1e4 ~ &quot;1k-10k&quot;, max_loan &lt; 1e5 ~ &quot;10k-100k&quot;, max_loan &lt; 1e6 ~ &quot;100k-1m&quot;, max_loan &lt; 1e7 ~ &quot;1m-10m&quot;, max_loan &lt; 1e8 ~ &quot;10m-100m&quot; )) %&gt;% count(sort_bucket) #allows for ordering in the graph properly max_size_histo$sort_bucket &lt;- parse_factor(max_size_histo$sort_bucket, levels=c(&quot;0-1&quot;, &quot;1-10&quot;, &quot;10-100&quot;, &quot;100-1k&quot;, &quot;1k-10k&quot;, &quot;10k-100k&quot;, &quot;100k-1m&quot;, &quot;1m-10m&quot;, &quot;10m-100m&quot;), ordered = TRUE) #LTV df_filtered &lt;- df_filtered %&gt;% mutate(ltv = net_borrow_position / collateral_position * 100, collateral_type = case_when(beth_position &gt; 0 &amp;&amp; bluna_position &gt; 0 ~ &quot;bLuna+bEth&quot;, bluna_position &gt; 0 ~ &quot;bLuna&quot;, beth_position &gt; 0 ~ &quot;bEth&quot;) ) %&gt;% filter(ltv != Inf) %&gt;% #remove the infinites due to daily rollup filter(ltv &lt;= 60) %&gt;% #clip at max LVR due to daily rollup mutate(loan_size = case_when( net_borrow_position &lt; 1 ~ &quot;0-1&quot;, net_borrow_position &lt; 10 ~ &quot;1-10&quot;, net_borrow_position &lt; 1e2 ~ &quot;10-100&quot;, net_borrow_position &lt; 1e3 ~ &quot;100-1k&quot;, net_borrow_position &lt; 1e4 ~ &quot;1k-10k&quot;, net_borrow_position &lt; 1e5 ~ &quot;10k-100k&quot;, net_borrow_position &lt; 1e6 ~ &quot;100k-1m&quot;, net_borrow_position &lt; 1e7 ~ &quot;1m-10m&quot;, net_borrow_position &lt; 1e8 ~ &quot;10m-100m&quot; )) #allows for ordering in the graph properly df_filtered$loan_size &lt;- parse_factor(df_filtered$loan_size, levels=c(&quot;0-1&quot;, &quot;1-10&quot;, &quot;10-100&quot;, &quot;100-1k&quot;, &quot;1k-10k&quot;, &quot;10k-100k&quot;, &quot;100k-1m&quot;, &quot;1m-10m&quot;, &quot;10m-100m&quot;), ordered = TRUE) #Add a week field df_filtered &lt;- df_filtered %&gt;% mutate(week = floor_date(date, unit=&quot;week&quot;)) #Calculate beth/bluna collateral values split df_collateral_split &lt;- df_filtered %&gt;% mutate(beth_collateral = beth_position * eth_usd, bluna_collateral = bluna_position * luna_usd) %&gt;% group_by(date) %&gt;% summarise( bEth = sum(beth_collateral) / (sum(beth_collateral)+sum(bluna_collateral)) * 100, bLuna = sum(bluna_collateral) / (sum(beth_collateral)+sum(bluna_collateral)) * 100 ) %&gt;% pivot_longer(!date, names_to=&quot;Collateral&quot;, values_to=&quot;percentage&quot;) . Here we attempt to answer the questions: . What is the number of users who are using Anchor to both borrow against their bAssets and place those borrows directly in Earn? What is the average leverage LTV risk they are taking in doing this? . Anchor is a borrow/lend protocol on the Terra Blockchain. It accepts assets for collateral (Luna and Eth), however these assets must be bonded first - a locked form of staking. Hence the collateral tokens accepted are bLuna and bEth. Once these bTokens are deposited in Anchor, users are able to borrow UST against, up to a maximum Loan-to-Value ratio of 60%. The LTV is simply the borrowed amount in UST divided by the current USD value of the collateral. If the LTV goes above 60% due to the collateral value falling, the loan can be liquidated and the borrower will lose a portion of the capital to repay the loan. . Anchor also has a deposit facility, where users can deposit UST and earn an interest rate from it. At the time of writing this article, the yields are very health. Anchor deposits earn 19.44% APR. This yield is slightly lower than the borrow interest rate - 21.1%, however there are ANC incentive rewards on the borrow side. This gives a net borrow interest rate of 18.8% in favour of the borrower. Yes, you read that correctly - you are paid to borrow money and paid again to deposit back into the protocol. . Number of Users Borrowing &amp; Depositing . With this deal on offer (possibly the best stablecoin yield in DeFi) it is no surprise that lots of users are taking up the offer. In pulling these data together, there were well over 0.5m transactions on the protocol. It was clear that users do multiple transactions - the table below shows 15,523 unique wallets who had both borrowed money from Anchor and deposited a sum back into the Earn portion. . A quick note on the data aggregation method - because of the large numbers of transactions, the data was simplified according the following rules: . Data was aggregated by day | A users collateral deposit &amp; withdrawal events were summed over the day, with the resulting collateral amount being the running total of all their collateral transactions to the end of that day | A users borrow &amp; repayment events were also summed over the day, with the resulting net borrowing position amount being the running total of all their borrow/repay transactions to the end of that day | Users deposit events were summed over the day | . This approach simplified the data considerably (0.5m events down to 65k events) but generated a small number of edge cases which didn&#39;t make sense after aggregation. These were driven by intra-day events - if a user deposited collateral, borrowed against it, deposited, withdrew the deposit, repaid the loan then withdrew the collateral, this would show up as a borrow event with no loan and no collateral. These small number of edge events (1000 or so) were filtered from the dataset. The remaining data will still be representative of user behaviour. There is also the underlying assumption that if a user deposited on the same day they borrowed, then they were depositing the borrowed money. . #Use the unfiltered - counts seem OK #%unload_ext google.colab.data_table %R df %&gt;% distinct(sender) %&gt;% count(name = &#39;Unique Wallets&#39;) . Unique Wallets . 1 15523 | . How much do People Borrow? . It&#39;s worth a look at what the typical loan sizes are for the people who are borrowing and depositing back into Anchor. The graph below shows, for each unique wallet, what was the peak borrow position for that wallet. In other words, of all the days that the user deposited back into Anchor Earn, what was the largest loan total they over those days. This gives us a feel for how deep each user was prepared to borrow from Anchor. . The graph below shows this distribution, with the maximum loan position along the bottom of the graph. It shows that most wallets borrow between 100 UST and 10,000 UST. Given the excellent returns, it&#39;s no surprise to see some big accounts. There are over 100 wallets who had over 1m UST outstanding, and 15 who had more than 15m UST outstanding. . What Collateral Assets are Used? . When Anchor launched the only available collateral asset was bonded Luna (bLuna), available from bonding Luna tokens to a validator via the Anchor protocol. In August 2021, Ether became an Anchor asset. This was done via the Lido protocol on Ethereum. Users are able to wrap ETH or stETH (ETH already staked on Lido) into a bEth token which represents their staked ETH on the Terra blockchain. This allows users to retain long term exposure to ETH, whilst taking advantage of the yields on offer in Anchor. Unsurprisingly, users have taken advantage of this. The graph below shows the % of collateral assets deposited in Anchor by our users (those who are both borrowing &amp; depositing on Anchor). After launch, the % of bEth as collateral quickly jumped to around 5% of the total. Expect to see this rise as more users find out about this yield opportunity. Anchor plans to add more assets to the potential collateral pool in the future. . #Plot the collateral split between beth &amp; bluna df_p = %R df_collateral_split fig = px.area(df_p , x=&quot;date&quot; , y=&quot;percentage&quot; , color=&quot;Collateral&quot; , template=&quot;simple_white&quot; , width=800, height=800/1.618 , title= &quot;Relative Value of Collateral Assets&quot; , labels=dict(date=&quot;Date&quot;, percentage=&quot;% of Anchor Collateral&quot;) ) fig.update_yaxes(title_text=&#39;% of Anchor Collateral&#39;) fig.update_xaxes(title_text=None) fig.update_layout(legend=dict( yanchor=&quot;top&quot;, y=0.90, xanchor=&quot;right&quot;, x=0.99 )) fig.show() . . . #Plot the loan amount distribution df_p = %R max_size_histo %&gt;% arrange(sort_bucket) fig = px.bar(df_p , x = &quot;sort_bucket&quot; , y = &quot;n&quot; , labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, n=&quot;Count of Wallets&quot;) , title= &quot;Distribution of a Wallet&#39;s Maximum Loan Position&quot; , template=&quot;simple_white&quot;, width=800, height=800/1.618 ) fig.update_yaxes(title_text=&#39;Count of Wallets&#39;) fig.update_xaxes(title_text=&#39;Maximum Size of Loan Position (UST)&#39;) #fig.update_traces(line_shape=&#39;spline&#39;, line_smoothing = 0.5) fig.show() . . . Loan to Valuation Ratio . Average LTV . To calculate the Loan to Valuation Ratios, on each day that a user made a deposit, we took the outstanding loan position and divided it by the collateral position on that day - using that days underlying asset prices. The table below shows the average LTV ratio for all users - around 32%. This is around half of the liquidation cuttof of 60%, and is lower than the Anchor recommended LTV of 45%. It appears users are relatively conservative with their loans - no surprises given how volatile the underlying assets can be. . %R df_filtered %&gt;% summarise(&quot;Average LTV %&quot; = round(mean(ltv),1), &quot;Weighted Average LTV %&quot; = round(sum(net_borrow_position) / sum(collateral_position) * 100,1)) . Average LTV % Weighted Average LTV % . 1 31.6 | 32.7 | . Distribution of LTVs . The graph below shows a histogram of the LTVs for all days where a wallet deposited borrowed funds in Anchor. Standout features include a big spike around 35% - this seems to be the most popular range. There are also spikes in 5% increments from 20% through to 45% - it seems that people gravitate towards multiples of 5. An evolutionary impact of having 5 fingers perhaps? It is also clear that most users borrow at less than the Anchor recommended LTV of 45%. There are a small numbers of thrillseekers however who deposit right up to the 60% limit. Liquidation stats for these users would be interesting. . #Histo for LTV df_p = %R df_filtered fig = px.histogram(df_p , x = &quot;ltv&quot; #, y = &quot;n&quot; #, labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, n=&quot;Count of Wallets&quot;) , title= &#39;Distribution of Loan to Valuation Ratio %&#39; , template=&quot;simple_white&quot;, width=800, height=800/1.618 ) fig.update_yaxes(title_text=&#39;Count of Loans&#39;) fig.update_xaxes(title_text=&#39;Loan to Valuation Ratio %&#39;) fig.add_shape(type=&quot;line&quot; , x0=40 , y0=0 , x1=40 , y1=2000 , line=dict(color=&quot;Black&quot;,width=3) ) fig.add_trace(go.Scatter( x=[41], y=[2000], text=[&quot;Anchor Recommended LTV&quot;], mode=&quot;text&quot; )) fig.update_layout(showlegend=False) fig.update_traces(textposition=&quot;middle right&quot;, selector=dict(type=&#39;scatter&#39;)) fig.show() . . . LTV by Borrow Position Size . Next we will see if there is any correlation between the size of a users outstanding borrow position and the LTV they choose when borrowing. The graph below shows a clear trend - lower value borrowers have a lower LTV and higher borrowers take on more liquidation risk. In particular, the accounts with &gt;1m UST outstanding have the highest LTVs - around 38% on average. It&#39;s possible that these users spend more time watching the markets, perhaps understand them better and are confident to take on a higher amount of risk. . The graph below this one is the same data, but shown with a boxplot. The same trend is evident, and we see that the &gt;1m UST borrowers have a narrower range of LTV. . #Average LTV by borrow position size df_p = %R df_filtered %&gt;% group_by(loan_size) %&gt;% summarise(ltv = mean(ltv)) %&gt;% arrange(loan_size) fig = px.bar(df_p , x = &quot;loan_size&quot; , y = &quot;ltv&quot; , labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, n=&quot;Count of Wallets&quot;) , title= &#39;Borrower LTV by Position Size&#39; , template=&quot;simple_white&quot;, width=800, height=800/1.618 ) fig.update_yaxes(title_text=&#39;Average LTV %&#39;) fig.update_xaxes(title_text=&#39;Borrowers Net Loan Position (UST)&#39;) #fig.update_traces(line_shape=&#39;spline&#39;, line_smoothing = 0.5) fig.show() . . . #Average LTV by borrow position size - boxplot df_p = %R df_filtered %&gt;% arrange(loan_size) #%&gt;% group_by(loan_size) %&gt;% summarise(ltv = mean(ltv)) %&gt;% arrange(loan_size) fig = px.box(df_p , x = &quot;loan_size&quot; , y = &quot;ltv&quot; , labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, n=&quot;Count of Wallets&quot;) , title= &#39;Borrower LTV by Position Size Boxplot&#39; , template=&quot;simple_white&quot;, width=800, height=800/1.618 ) fig.update_yaxes(title_text=&#39;Average LTV %&#39;) fig.update_xaxes(title_text=&#39;Borrowers Net Loan Position (UST)&#39;) #fig.update_traces(line_shape=&#39;spline&#39;, line_smoothing = 0.5) fig.show() . . . LTV Over Time . Looking at LTV over time, we see some variation - LTV ranges between around 28% at the low point, and around 35% at a high. Interesting datapoints include the sharp drop in LTV in mid-May 2021. THis was the time when crypto asset prices suffered sharp and substantial drops. It&#39;s possible that higher leveraged positions were flushed out by liquidations during these rapid price falls. The sharp rise in LTV from June through to August coincided with Luna rising in price from USD 6 to USD 30 - this obviously gave users confidence to borrow against these rising positions &amp; take advantage of the juicy Anchor borrow &amp; deposit rates. . #Change over time df_p = %R df_filtered %&gt;% group_by(week) %&gt;% summarise(ltv = mean(ltv)) %&gt;% arrange(week) fig = px.line(df_p , x = &quot;week&quot; , y = &quot;ltv&quot; , labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, n=&quot;Count of Wallets&quot;) , title= &#39;Borrower LTV over Time&#39; , template=&quot;simple_white&quot;, width=800, height=800/1.618 ) fig.update_yaxes(title_text=&#39;Average LTV %&#39;) fig.update_xaxes(title_text=&#39;Borrowers Net Loan Position (UST)&#39;) fig.update_traces(line_shape=&#39;spline&#39;, line_smoothing = 0.5) fig.show() . . . LTV by Borrow Position Size over Time . We will repeat the chart from above, but split by our borrow size cohorts from the previous sections. There are common trends evident in the data - the May 2021 price crash seemed to impact all users. An interesting group is the 1m-10m UST borrow group - they seem to push the LTV consistently up towards 40%, indicating a purposeful and managed approach to farming yield on Anchor. . #Change over time df_p = %R df_filtered %&gt;% group_by(loan_size, week) %&gt;% summarise(ltv = mean(ltv)) %&gt;% arrange(loan_size, week) fig = px.line(df_p , x = &quot;week&quot; , y = &quot;ltv&quot; , facet_col = &#39;loan_size&#39; , facet_col_wrap=4 , labels=dict(sort_bucket=&quot;Maximum Loan Position&quot;, ltv=&quot;Loan to Value Ratio %&quot;) , title= &#39;Borrower LTV by Position Size over Time&#39; , template=&quot;simple_white&quot; , width=1200, height=1200/1.618 ) #fig.update_yaxes(title_text=&#39;Average LTV %&#39;) #fig.update_xaxes(title_text=&#39;Borrowers Net Loan Position (UST)&#39;) fig.for_each_annotation(lambda a: a.update(text=a.text.split(&quot;=&quot;)[-1])) fig.update_traces(line_shape=&#39;spline&#39;, line_smoothing = 0.5) fig.show() . . . Conclusions . The on-chain data has shown over 15,000 unique wallets which are both borrowing from Anchor and depositing in the Earn facility at the same time. These users, on average have an LTV of around 32%. This LTV differs depending on the size of the loan, with larger users prepared to take on more liquidation risk. The LTV has changed over time, seemingly in response to market pricing changes in underlying assets. In particular, there was suggestion that rapid price falls caused liquidations, leading to lower overall LTVs. .",
            "url": "https://scottincrypto.github.io/analytics/2021/09/08/Anchor-bAssets-Usage.html",
            "relUrl": "/2021/09/08/Anchor-bAssets-Usage.html",
            "date": " • Sep 8, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://scottincrypto.github.io/analytics/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://scottincrypto.github.io/analytics/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://scottincrypto.github.io/analytics/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://scottincrypto.github.io/analytics/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}